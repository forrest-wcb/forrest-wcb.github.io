<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CUDA学习笔记 | Forrest's Blog🍭</title><meta name="author" content="Forrest"><meta name="copyright" content="Forrest"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="白嫖的英伟达online course">
<meta property="og:type" content="article">
<meta property="og:title" content="CUDA学习笔记">
<meta property="og:url" content="https://forrest-wcb.github.io/2023/12/29/cuda/index.html">
<meta property="og:site_name" content="Forrest&#39;s Blog🍭">
<meta property="og:description" content="白嫖的英伟达online course">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312292229107.jpg">
<meta property="article:published_time" content="2023-12-29T14:25:49.000Z">
<meta property="article:modified_time" content="2023-12-29T14:50:32.088Z">
<meta property="article:author" content="Forrest">
<meta property="article:tag" content="cuda加速计算">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312292229107.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202309101330868.png"><link rel="canonical" href="https://forrest-wcb.github.io/2023/12/29/cuda/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Forrest","link":"链接: ","source":"来源: Forrest's Blog🍭","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CUDA学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-29 22:50:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 22
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202309171033347.jpg" onerror="onerror=null;src='https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-solid fa-message fa-sm"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312292229107.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Forrest's Blog🍭"><img class="site-icon" src="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202309101330868.png"/><span class="site-name">Forrest's Blog🍭</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-solid fa-message fa-sm"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CUDA学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-29T14:25:49.000Z" title="发表于 2023-12-29 22:25:49">2023-12-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-29T14:50:32.088Z" title="更新于 2023-12-29 22:50:32">2023-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CUDA学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>CUDA C/C++编程的学习</h1>
<p><strong>本文基于英伟达提供的线上自主学习课程</strong></p>
<p>加速计算正在取代 CPU 计算，成为最佳计算做法。加速计算带来的层出不穷的突破性进展、对加速应用程序日益增长的需求、轻松编写加速计算的编程规范以及支持加速计算的硬件的不断改进，所有这一切都在推动计算方式必然会过渡到加速计算。</p>
<h2 id="为GPU编写应用程序代码">为GPU编写应用程序代码</h2>
<p>以下是一个 <code>.cu</code> 文件（<code>.cu</code> 是 CUDA 加速程序的文件扩展名）。其中包含两个函数，第一个函数将在 CPU 上运行，第二个将在 GPU 上运行。请抽点时间找出这两个函数在定义方式和调用方式上的差异。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CPUFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This function is defined to run on the CPU.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">GPUFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This function is defined to run on the GPU.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CPUFunction();</span><br><span class="line"></span><br><span class="line">  GPUFunction&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是一些需要特别注意的重要代码行，以及加速计算中使用的一些其他常用术语：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__global__ void GPUFunction()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__global__</code> 关键字表明以下函数将在 GPU 上运行并可<strong>全局</strong>调用，而在此种情况下，则指由 CPU 或 GPU 调用。</li>
<li>通常，我们将在 CPU 上执行的代码称为<strong>主机</strong>代码，而将在 GPU 上运行的代码称为<strong>设备</strong>代码。</li>
<li>注意返回类型为 <code>void</code>。使用 <code>__global__</code> 关键字定义的函数需要返回 <code>void</code> 类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPUFunction&lt;&lt;&lt;1, 1&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>通常，当调用要在 GPU 上运行的函数时，我们将此种函数称为<strong>已启动</strong>的<strong>核函数</strong>。</li>
<li>启动核函数时，我们必须提供<strong>执行配置</strong>，即在向核函数传递任何预期参数之前使用 <code>&lt;&lt;&lt; ... &gt;&gt;&gt;</code> 语法完成的配置。</li>
<li>在宏观层面，程序员可通过执行配置为核函数启动指定<strong>线程层次结构</strong>，从而定义线程组（称为<strong>线程块</strong>）的数量，以及要在每个线程块中执行的<strong>线程</strong>数量。稍后将在本实验深入探讨执行配置，但现在请注意正在使用包含 <code>1</code> 线程（第二个配置参数）的 <code>1</code> 线程块（第一个执行配置参数）启动核函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cudaDeviceSynchronize();</span><br></pre></td></tr></table></figure>
<ul>
<li>与许多 C/C++ 代码不同，核函数启动方式为<strong>异步</strong>：CPU 代码将继续执行<em>而无需等待核函数完成启动</em>。</li>
<li>调用 CUDA 运行时提供的函数 <code>cudaDeviceSynchronize</code> 将导致主机 (CPU) 代码暂作等待，直至设备 (GPU) 代码执行完成，才能在 CPU 上恢复执行。</li>
</ul>
<h3 id="练习">练习</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">helloCPU</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello from the CPU.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">helloGPU</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello from the GPU.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  helloCPU();</span><br><span class="line">    </span><br><span class="line">  helloGPU&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是对 nvidia所给例子<a target="_blank" rel="noopener" href="http://dli-604a4aa51b37-99aaad.aws.labs.courses.nvidia.com/lab/edit/01-hello/01-hello-gpu.cu"><code>01-hello-gpu.cu</code></a> 的重构，运行结果为先后次序打印Hello from the CPU.和Hello from the GPU.</p>
<ul>
<li>
<p>从核函数定义中删除关键字 <code>__global__</code>。注意错误中的行号：您认为错误中的 \”configured\” 是什么意思？完成后，请替换 <code>__global__</code>。</p>
<p>报错a host function call cannot be configured。</p>
<p>未声明关键字_<em>global</em>_，函数不可被&lt;&lt;&lt;…&gt;&gt;&gt;配置</p>
</li>
<li>
<p>移除执行配置：您对 \”configured\” 的理解是否仍旧合理？完成后，请替换执行配置。</p>
<p>报错a __global__ function call must be configured。</p>
<p>启动核函数必须提供执行配置。</p>
</li>
<li>
<p>移除对 <code>cudaDeviceSynchronize</code> 的调用。在编译和运行代码之前，猜猜会发生什么情况，可以回顾一下核函数采取的是异步启动，且 <code>cudaDeviceSynchronize</code> 会使主机执行暂作等待，直至核函数执行完成后才会继续。完成后，请替换对 <code>cudaDeviceSynchronize</code> 的调用。</p>
<p>只打印Hello from the CPU.</p>
<p>核函数异步启动，CPU将继续执行而不会等待GPU执行完成</p>
</li>
<li>
<p>重构 <code>01-hello-gpu.cu</code>，以便 <code>Hello from the GPU</code> 在 <code>Hello from the CPU</code> <strong>之前</strong>打印。</p>
<p>将<code>helloGPU&lt;&lt;&lt;1,1&gt;&gt;&gt;();</code>及<code>cudaDeviceSynchronize();</code>移至helloCPU()前，main()如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">helloGPU&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">cudaDeviceSynchronize();</span><br><span class="line">helloCPU();</span><br></pre></td></tr></table></figure>
<p>cudaDeviceSynchronize();必须调至helloCPU前，若只改动helloGPU打印结果顺序不会变。</p>
</li>
<li>
<p>重构 <code>01-hello-gpu.cu</code>，以便 <code>Hello from the GPU</code> 打印<strong>两次</strong>，一次是在 <code>Hello from the CPU</code> <strong>之前</strong>，另一次是在 <code>Hello from the CPU</code> <strong>之后</strong>。</p>
<p>重构后main函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">helloGPU&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">cudaDeviceSynchronize();<span class="comment">//等待第一个Hello from the GPU</span></span><br><span class="line">helloCPU();<span class="comment">//打印Hello from the CPU</span></span><br><span class="line">helloGPU&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">cudaDeviceSynchronize();<span class="comment">//等待第二个Hello from the GPU</span></span><br></pre></td></tr></table></figure>
<h3 id="编译并运行加速后的CUDA代码">编译并运行加速后的CUDA代码</h3>
<p>CUDA 平台附带 <a target="_blank" rel="noopener" href="http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html"><strong>NVIDIA CUDA 编译器</strong></a> <code>nvcc</code>，可以编译 CUDA 加速应用程序，其中包含主机和设备代码。</p>
<p>曾使用过 <code>gcc</code> 的用户会对 <code>nvcc</code> 感到非常熟悉。例如，编译 <code>some-CUDA.cu</code> 文件就很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvcc -arch=sm_70 -o out some-CUDA.cu -run</span><br></pre></td></tr></table></figure>
<ul>
<li><code>nvcc</code> 是使用 <code>nvcc</code> 编译器的命令行命令。</li>
<li>将 <code>some-CUDA.cu</code> 作为文件传递以进行编译。</li>
<li><code>o</code> 标志用于指定编译程序的输出文件。</li>
<li><code>arch</code> 标志表示该文件必须编译为哪个<strong>架构</strong>类型。本示例中，<code>sm_70</code> 将用于专门针对本实验运行的 Volta GPU 进行编译，但有意深究的用户可以参阅有关 <a target="_blank" rel="noopener" href="http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#options-for-steering-gpu-code-generation"><code>arch</code> 标志</a>、<a target="_blank" rel="noopener" href="http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#gpu-feature-list">虚拟架构特性</a> 和 <a target="_blank" rel="noopener" href="http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#gpu-feature-list">GPU特性</a> 的文档。</li>
<li>为方便起见，提供 <code>run</code> 标志将执行已成功编译的二进制文件。</li>
</ul>
</li>
</ul>
<h2 id="启动并行运行的核函数">启动并行运行的核函数</h2>
<p>程序员可通过执行配置指定有关如何启动核函数以在多个 GPU <strong>线程</strong>中并行运行的详细信息。更准确地说，程序员可通过执行配置指定线程组（称为<strong>线程块</strong>或简称为<strong>块</strong>）数量以及其希望每个线程块所包含的线程数量。执行配置的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;线程块数, 每个线程块的线程数&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>启动核函数时，核函数代码由每个已配置的线程块中的每个线程执行</strong>。</p>
<p>因此，如果假设已定义一个名为 <code>someKernel</code> 的核函数，则下列情况为真：</p>
<ul>
<li><code>someKernel&lt;&lt;&lt;1, 1&gt;&gt;()</code> 配置为在具有单线程的单个线程块中运行后，将只运行一次。</li>
<li><code>someKernel&lt;&lt;&lt;1, 10&gt;&gt;()</code> 配置为在具有 10 线程的单个线程块中运行后，将运行 10 次。</li>
<li><code>someKernel&lt;&lt;&lt;10, 1&gt;&gt;()</code> 配置为在 10 个线程块（每个均具有单线程）中运行后，将运行 10 次。</li>
<li><code>someKernel&lt;&lt;&lt;10, 10&gt;&gt;()</code> 配置为在 10 个线程块（每个均具有 10 线程）中运行后，将运行 100 次。</li>
</ul>
<h2 id="线程和块的索引">线程和块的索引</h2>
<p>每个线程在其线程块内部均会被分配一个索引，从 <code>0</code> 开始。此外，每个线程块也会被分配一个索引，并从 <code>0</code> 开始。正如线程组成线程块，线程块又会组成<strong>网格</strong>，而网格是 CUDA 线程层次结构中级别最高的实体。简言之，CUDA 核函数在由一个或多个线程块组成的网格中执行，且每个线程块中均包含相同数量的一个或多个线程。</p>
<ul>
<li>gridDim.x：网格中的线程块数</li>
<li>blockIdx.x：网格中线程块的索引</li>
<li>blockDim.x：线程块中的线程数</li>
<li>threadIdx.x：块中线程的索引</li>
</ul>
<p>CUDA 核函数可以访问能够识别如下两种索引的特殊变量：正在执行核函数的线程（位于线程块内）索引和线程所在的线程块（位于网格内）索引。这两种变量分别为 <code>threadIdx.x</code> 和 <code>blockIdx.x</code>。</p>
<h2 id="加速for循环">加速for循环</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> N = <span class="number">2</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如要并行此循环，必须执行以下 2 个步骤：</p>
<ul>
<li>必须编写完成<strong>循环的单次迭代</strong>工作的核函数。</li>
<li>由于核函数与其他正在运行的核函数无关，因此执行配置必须使核函数执行正确的次数，例如循环迭代的次数。</li>
</ul>
<h3 id="练习：使用单个线程块加速for循环">练习：使用单个线程块加速for循环</h3>
<p><a target="_blank" rel="noopener" href="http://dli-604a4aa51b37-24abdb.aws.labs.courses.nvidia.com/lab/edit/04-loops/01-single-block-loop.cu"><code>01-single-block-loop.cu</code></a> 内的 <code>loop</code> 函数运行着一个“for 循环”并将连续打印 <code>0</code> 至 <code>9</code> 之间的所有数字。将 <code>loop</code> 函数重构为 CUDA 核函数，使其在启动后并行执行 <code>N</code> 次迭代。重构成功后，应仍能打印 <code>0</code> 至 <code>9</code> 之间的所有数字。</p>
<p>原代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;N ; i++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This is iteration number %d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> N =<span class="number">10</span>;</span><br><span class="line">  loop(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重构后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This is iteration number %d\n&quot;</span>,threadIdx.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  loop&lt;&lt;&lt;<span class="number">1</span>,<span class="number">10</span>&gt;&gt;&gt;();</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：每个线程块内，thread.x的输出顺序是有序的，而不同线程块间的输出是无序的。如下，输出是无序的。但是若改为 loop&lt;&lt;&lt;10,2&gt;&gt;&gt;();可以发现仅线程块输出结果间是无序的，同一线程块内线程输出结果是有序的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This is iteration number %d\n&quot;</span>,blockIdx.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  loop&lt;&lt;&lt;<span class="number">10</span>,<span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>*查阅了一些资料，询问了老师之后，得知严格意义上线程块和线程的输出顺序是无法控制的，“并行本身其实就不应该控制先后顺序的，如果需要控制的话，那就说明这个任务不适合做矢量化了，因为他是顺序依赖的”，这里的线程输出有序，猜测是因为显示系统进行了后处理。*所以在实际使用中需要考虑使用线程块加速的适用性。</p>
<h2 id="调整线程块的大小以实现更多的并行化">调整线程块的大小以实现更多的并行化</h2>
<p>线程块包含的线程具有数量限制：确切地说是 1024 个。为增加加速应用程序中的并行量，我们必须要能在多个线程块之间进行协调。</p>
<p>CUDA 核函数可以访问给出块中线程数的特殊变量：<code>blockDim.x</code>。通过将此变量与 <code>blockIdx.x</code> 和 <code>threadIdx.x</code> 变量结合使用，并借助惯用表达式 <code>threadIdx.x + blockIdx.x * blockDim.x</code> 在包含多个线程的多个线程块之间组织并行执行，并行性将得以提升。以下是详细示例。</p>
<p>执行配置 <code>&lt;&lt;&lt;10, 10&gt;&gt;&gt;</code> 将启动共计拥有 100 个线程的网格，这些线程均包含在由 10 个线程组成的 10 个线程块中。因此，我们希望每个线程（<code>0</code> 至 <code>99</code> 之间）都能计算该线程的某个唯一索引。</p>
<ul>
<li>如果线程块 <code>blockIdx.x</code> 等于 <code>0</code>，则 <code>blockIdx.x * blockDim.x</code> 为 <code>0</code>。向 <code>0</code> 添加可能的 <code>threadIdx.x</code> 值（<code>0</code> 至 <code>9</code>），之后便可在包含 100 个线程的网格内生成索引 <code>0</code> 至 <code>9</code>。</li>
<li>如果线程块 <code>blockIdx.x</code> 等于 <code>1</code>，则 <code>blockIdx.x * blockDim.x</code> 为 <code>10</code>。向 <code>10</code> 添加可能的 <code>threadIdx.x</code> 值（<code>0</code> 至 <code>9</code>），之后便可在包含 100 个线程的网格内生成索引 <code>10</code> 至 <code>19</code>。</li>
</ul>
<h2 id="分配将要在GPU和CPU上访问的内存">分配将要在GPU和CPU上访问的内存</h2>
<p>CUDA 的最新版本（版本 6 和更高版本）已能轻松分配可用于 CPU 主机和任意数量 GPU 设备的内存。尽管现今有许多适用于内存管理并可支持加速应用程序中最优性能的 <a target="_blank" rel="noopener" href="http://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#memory-optimizations">中高级技术</a>，但我们现在要介绍的基础 CUDA 内存管理技术不但能够支持远超 CPU 应用程序的卓越性能，而且几乎不会产生任何开发人员成本。</p>
<p>如要分配和释放内存，并获取可在主机和设备代码中引用的指针，请使用 <code>cudaMallocManaged</code> 和 <code>cudaFree</code> 取代对 <code>malloc</code> 和 <code>free</code> 的调用，如下例所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有CPU</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">2</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="type">size_t</span> size = N * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> *a;</span><br><span class="line"></span><br><span class="line">a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加速后</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">2</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="type">size_t</span> size = N * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> *a;</span><br><span class="line"><span class="comment">// a的地址作为第一个参数传递</span></span><br><span class="line"><span class="built_in">cudaMallocManaged</span>(&amp;a, size);</span><br><span class="line"><span class="built_in">cudaFree</span>(a);</span><br></pre></td></tr></table></figure>
<h2 id="网格大小与工作量不匹配">网格大小与工作量不匹配</h2>
<p>可能会出现这样的情况，执行配置所创建的线程数无法匹配为实现并行循环所需的线程数。</p>
<p>一个常见的例子与希望选择的最佳线程块大小有关。例如，鉴于 GPU 的硬件特性，所含线程的数量为 32 的倍数的线程块是最理想的选择，因其具备性能上的优势。假设我们要启动一些线程块且每个线程块中均包含 256 个线程（32 的倍数），并需运行 1000 个并行任务（此处使用极小的数量以便于说明），则任何数量的线程块均无法在网格中精确生成 1000 个总线程，因为没有任何整数值在乘以 32 后可以恰好等于 1000。</p>
<p>这个问题可以通过以下方式轻松地解决：</p>
<ul>
<li>编写执行配置，使其创建的线程数<strong>超过</strong>执行分配工作所需的线程数。</li>
<li>将一个值作为参数传递到核函数 (<code>N</code>) 中，该值表示要处理的数据集总大小或完成工作所需的总线程数。</li>
<li>计算网格内的线程索引后（使用 <code>threadIdx + blockIdx*blockDim</code>），请检查该索引是否超过 <code>N</code>，并且只在不超过的情况下执行与核函数相关的工作。</li>
</ul>
<p>以下是编写执行配置的惯用方法示例，适用于 <code>N</code> 和线程块中的线程数已知，但无法保证网格中的线程数和 <code>N</code> 之间完全匹配的情况。如此一来，便可确保网格中至少始终拥有 <code>N</code> 所需的线程数，且超出的线程数至多仅可相当于 1 个线程块的线程数量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N已知</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个线程块均包含256个线程</span></span><br><span class="line"><span class="type">size_t</span> threads_per_block = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保网格中至少始终拥有 `N` 所需的线程数，且超出的线程数至多仅可相当于 1 个线程块的线程数量</span></span><br><span class="line"><span class="type">size_t</span> number_of_blocks = (N + threads_per_block - <span class="number">1</span>) / threads_per_block;</span><br><span class="line"></span><br><span class="line">some_kernel&lt;&lt;&lt;number_of_blocks, threads_per_block&gt;&gt;&gt;(N);</span><br></pre></td></tr></table></figure>
<p>由于上述执行配置致使网格中的线程数超过 <code>N</code>，因此需要注意 <code>some_kernel</code> 定义中的内容，以确保 <code>some_kernel</code> 在由其中一个 ”额外的” 线程执行时不会尝试访问超出范围的数据元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="title">some_kernel</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> idx = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (idx &lt; N) <span class="comment">// 检查线程索引是否超过N</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//条件满足时执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跨网格的循环">跨网格的循环</h2>
<p>或出于选择，为了要创建具有超高性能的执行配置，或出于需要，一个网格中的线程数量可能会小于数据集的大小。请思考一下包含 1000 个元素的数组和包含 250 个线程的网格（此处使用极小的规模以便于说明）。此网格中的每个线程将需使用 4 次。如要实现此操作，一种常用方法便是在核函数中使用<strong>跨网格循环</strong>。</p>
<p>在跨网格循环中，每个线程将在网格内使用 <code>threadIdx + blockIdx*blockDim</code> 计算自身唯一的索引，并对数组内该索引的元素执行相应运算，然后将网格中的线程数添加到索引并重复此操作，直至超出数组范围。例如，对于包含 500 个元素的数组和包含 250 个线程的网格，网格中索引为 20 的线程将执行如下操作：</p>
<ul>
<li>对包含 500 个元素的数组的元素 20 执行相应运算</li>
<li>将其索引增加 250，使网格的大小达到 270</li>
<li>对包含 500 个元素的数组的元素 270 执行相应运算</li>
<li>将其索引增加 250，使网格的大小达到 520</li>
<li>由于 520 现已超出数组范围，因此线程将停止工作</li>
</ul>
<p>CUDA 提供一个可给出网格中线程块数的特殊变量：<code>gridDim.x</code>。然后计算网格中的总线程数，即网格中的线程块数乘以每个线程块中的线程数：<code>gridDim.x * blockDim.x</code>。带着这样的想法来看看以下核函数中网格跨度循环的详细示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__global <span class="type">void</span> <span class="title">kernel</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> indexWithinTheGrid = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="type">int</span> gridStride = gridDim.x * blockDim.x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = indexWithinTheGrid; i &lt; N; i += gridStride)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// do work on a[i];</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理">错误处理</h2>
<ol>
<li>与在任何应用程序中一样，加速 CUDA 代码中的错误处理同样至关重要。即便不是大多数，也有许多 CUDA 函数（例如，<a target="_blank" rel="noopener" href="http://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY">内存管理函数</a>）会返回类型为 <code>cudaError_t</code> 的值，该值可用于检查调用函数时是否发生错误。以下是对调用 <code>cudaMallocManaged</code> 函数执行错误处理的示例：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cudaError_t err;</span><br><span class="line">err = <span class="built_in">cudaMallocManaged</span>(&amp;a, N)                    <span class="comment">// Assume the existence of `a` and `N`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)                           <span class="comment">// `cudaSuccess` is provided by CUDA.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(err)); <span class="comment">// `cudaGetErrorString` is provided by CUDA.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>启动定义为返回 <code>void</code> 的核函数后，将不会返回类型为 <code>cudaError_t</code> 的值。为检查启动核函数时是否发生错误（例如，如果启动配置错误），CUDA 提供 <code>cudaGetLastError</code> 函数，该函数会返回类型为 <code>cudaError_t</code> 的值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This launch should cause an error, but the kernel itself</span></span><br><span class="line"><span class="comment"> * cannot return it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">someKernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">-1</span>&gt;&gt;&gt;();  <span class="comment">// -1 is not a valid number of threads.</span></span><br><span class="line"></span><br><span class="line">cudaError_t err;</span><br><span class="line">err = <span class="built_in">cudaGetLastError</span>(); <span class="comment">// `cudaGetLastError` will return the error from above.</span></span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>最后，为捕捉异步错误（例如，在异步核函数执行期间），请务必检查后续同步 CUDA 运行时 API 调用所返回的状态（例如 <code>cudaDeviceSynchronize</code>）；如果之前启动的其中一个核函数失败，则将返回错误。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cudaError_t err;</span><br><span class="line">err = cudaDeviceSynchronize();                <span class="comment">// Assume the existence of `a` and `N`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)                           <span class="comment">// `cudaSuccess` is provided by CUDA.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, cudaGetErrorString(err)); <span class="comment">// `cudaGetErrorString` is provided by CUDA.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CUDA错误处理功能">CUDA错误处理功能</h3>
<p>创建一个包装 CUDA 函数调用的宏对于检查错误十分有用。以下是一个宏示例，您可以在余下练习中随时使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> cudaError_t <span class="title">checkCuda</span><span class="params">(cudaError_t result)</span><span class="comment">//inline 关键字提示编译器尝试将该函数内联，这可以提高性能。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (result != cudaSuccess) &#123;<span class="comment">//这个条件检查CUDA操作的结果是否不等于 cudaSuccess。如果发生错误，则执行if块内的代码。</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;CUDA Runtime Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(result));</span><br><span class="line">    <span class="built_in">assert</span>(result == cudaSuccess);<span class="comment">//使用 assert 宏检查结果是否等于 cudaSuccess。如果不等于，这会触发一个断言失败，如果启用了断言，程序将终止。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*...*/</span></span><br><span class="line">  <span class="built_in">checkCuda</span>( <span class="built_in">cudaDeviceSynchronize</span>() )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2维和3维的网格和块">2维和3维的网格和块</h2>
<p>可以将网格和线程块定义为最多具有 3 个维度。使用多个维度定义网格和线程块绝不会对其性能造成任何影响，但这在处理具有多个维度的数据时可能非常有用，例如 2D 矩阵。如要定义二维或三维网格或线程块，可以使用 CUDA 的 <code>dim3</code> 类型，即如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">threads_per_block</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">number_of_blocks</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">someKernel&lt;&lt;&lt;number_of_blocks, threads_per_block&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>鉴于以上示例，<code>someKernel</code> 内部的变量 <code>gridDim.x</code>、<code>gridDim.y</code>、<code>blockDim.x</code> 和 <code>blockDim.y</code> 均将等于 <code>16</code>。</p>
<p>此处介绍一个万能的索引计算式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tid = blockIdx.z * (gridDim.x * gridDim.y) * (blockDim.x * blockDim.y * blockDim.z)\ </span><br><span class="line">    <span class="comment">//块在z方向上的索引</span></span><br><span class="line">          + blockIdx.y * gridDim.x * (blockDim.x * blockDim.y * blockDim.z) \			</span><br><span class="line">    <span class="comment">//块在y方向上的索引</span></span><br><span class="line">          + blockIdx.x * (blockDim.x * blockDim.y * blockDim.z) \                      </span><br><span class="line">    <span class="comment">//块在x方向上的索引</span></span><br><span class="line">      	  + threadIdx.z * (blockDim.x * blockDim.y) \                                 </span><br><span class="line">    <span class="comment">//线程在z方向上的索引</span></span><br><span class="line">          + threadIdx.y * blockDim.x \                                               </span><br><span class="line">    <span class="comment">//线程在y方向上的索引</span></span><br><span class="line">          + threadIdx.x;                                                            </span><br><span class="line">    <span class="comment">//线程在x方向上的索引</span></span><br></pre></td></tr></table></figure>
<h1><strong>使用 CUDA C/C++ 统一内存和 Nsight Systems (nsys) 管理加速应用程序内存</strong></h1>
<h2 id="学习目标">学习目标</h2>
<p>当您在本实验完成学习后，您将能够：</p>
<ul>
<li>使用 <strong>Nsight Systems命令行分析器</strong> (<strong>nsys</strong>) 分析被加速的应用程序的性能。</li>
<li>利用对<strong>流多处理器</strong>的理解优化执行配置。</li>
<li>理解<strong>统一内存</strong>在页错误和数据迁移方面的行为。</li>
<li>使用<strong>异步内存预取</strong>减少页错误和数据迁移以提高性能。</li>
<li>采用循环式的迭代开发加快应用程序的优化加速和部署。</li>
</ul>
<h2 id="使用nsys性能分析器帮助应用程序迭代地进行优化">使用nsys性能分析器帮助应用程序迭代地进行优化</h2>
<p>如要确保优化加速代码库的尝试真正取得成功，唯一方法便是分析应用程序以获取有关其性能的定量信息。<code>nsys</code> 是指 NVIDIA 的Nsight System命令行分析器。该分析器附带于CUDA工具包中，提供分析被加速的应用程序性能的强大功能。</p>
<p><code>nsys</code> 使用起来十分简单，最基本用法是向其传递使用 <code>nvcc</code> 编译的可执行文件的路径。随后 <code>nsys</code> 会继续执行应用程序，并在此之后打印应用程序 GPU 活动的摘要输出、CUDA API 调用以及<strong>统一内存</strong>活动的相关信息。我们稍后会在本实验中详细介绍这一主题。</p>
<p>在加速应用程序或优化已经加速的应用程序时，我们应该采用科学的迭代方法。作出更改后需分析应用程序、做好记录并记录任何重构可能会对性能造成何种影响。尽早且经常进行此类观察通常会让您轻松获得足够的性能提升，以助您发布加速应用程序。此外，经常分析应用程序将使您了解到对 CUDA 代码库作出的特定更改会对其实际性能造成何种影响：而当只在代码库中进行多种更改后再分析应用程序时，将很难得知这一点。</p>
<p><code>nsys profile</code>将生成一个<code>qdrep</code>报告文件，该文件可以以多种方式使用。 我们在这里使用<code>--stats = true</code>标志表示我们希望打印输出摘要统计信息。 输出的信息有很多，包括：</p>
<ul>
<li>配置文件配置详细信息</li>
<li>报告文件的生成详细信息</li>
<li><strong>CUDA API统计信息</strong></li>
<li><strong>CUDA核函数的统计信息</strong></li>
<li><strong>CUDA内存操作统计信息（时间和大小）</strong></li>
<li>操作系统内核调用接口的统计信息</li>
</ul>
<p>值得一提的是，默认情况下，<code>nsys profile</code>不会覆盖现有的报告文件。 这样做是为了防止在进行概要分析时意外丢失工作。 如果出于某种原因，您宁愿覆盖现有的报告文件，例如在快速迭代期间，可以向<code>nsys profile</code>提供<code>-f</code>标志以允许覆盖现有的报告文件。</p>
<p><strong>练习</strong></p>
<p>优化前<a target="_blank" rel="noopener" href="http://dli-604a4aa51b37-ee1ab7.aws.labs.courses.nvidia.com/lab/edit/01-vector-add/01-vector-add.cu">01-vector-add.cu</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Host function to initialize vector elements. This function</span></span><br><span class="line"><span class="comment"> * simply initializes each element to equal its index in the</span></span><br><span class="line"><span class="comment"> * vector.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWith</span><span class="params">(<span class="type">float</span> num, <span class="type">float</span> *a, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i] = num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Device kernel stores into `result` the sum of each</span></span><br><span class="line"><span class="comment"> * same-indexed value of `a` and `b`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addVectorsInto</span><span class="params">(<span class="type">float</span> *result, <span class="type">float</span> *a, <span class="type">float</span> *b, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; N; i += stride)</span><br><span class="line">  &#123;</span><br><span class="line">    result[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Host function to confirm values in `vector`. This function</span></span><br><span class="line"><span class="comment"> * assumes all values are the same `target` value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkElementsAre</span><span class="params">(<span class="type">float</span> target, <span class="type">float</span> *vector, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vector[i] != target)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;FAIL: vector[%d] - %0.0f does not equal %0.0f\n&quot;</span>, i, vector[i], target);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Success! All values calculated correctly.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">2</span>&lt;&lt;<span class="number">24</span>;</span><br><span class="line">  <span class="type">size_t</span> size = N * <span class="built_in">sizeof</span>(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> *a;</span><br><span class="line">  <span class="type">float</span> *b;</span><br><span class="line">  <span class="type">float</span> *c;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;a, size);</span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;b, size);</span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;c, size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initWith</span>(<span class="number">3</span>, a, N);</span><br><span class="line">  <span class="built_in">initWith</span>(<span class="number">4</span>, b, N);</span><br><span class="line">  <span class="built_in">initWith</span>(<span class="number">0</span>, c, N);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> threadsPerBlock;</span><br><span class="line">  <span class="type">size_t</span> numberOfBlocks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * nsys should register performance changes when execution configuration</span></span><br><span class="line"><span class="comment">   * is updated.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  threadsPerBlock = <span class="number">1</span>;</span><br><span class="line">  numberOfBlocks = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  cudaError_t addVectorsErr;</span><br><span class="line">  cudaError_t asyncErr;</span><br><span class="line"></span><br><span class="line">  addVectorsInto&lt;&lt;&lt;numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(c, a, b, N);</span><br><span class="line"></span><br><span class="line">  addVectorsErr = <span class="built_in">cudaGetLastError</span>();</span><br><span class="line">  <span class="keyword">if</span>(addVectorsErr != cudaSuccess) <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(addVectorsErr));</span><br><span class="line"></span><br><span class="line">  asyncErr = <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">  <span class="keyword">if</span>(asyncErr != cudaSuccess) <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(asyncErr));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">checkElementsAre</span>(<span class="number">7</span>, c, N);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaFree</span>(a);</span><br><span class="line">  <span class="built_in">cudaFree</span>(b);</span><br><span class="line">  <span class="built_in">cudaFree</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化将77行的的threadsPerblock改为1024即可，分析可得核函数运行时间加快了一个量级，此外cudaDeviceSynchronize()运行时间也大幅缩短，易于理解。</p>
<h2 id="流多处理器（Streaming-Multiprocessors）及查询GPU的设备配置">流多处理器（Streaming Multiprocessors）及查询GPU的设备配置</h2>
<h3 id="流多处理器和Warps">流多处理器和Warps</h3>
<p>运行 CUDA 应用程序的 GPU 具有称为<strong>流多处理器</strong>（或 <strong>SM</strong>）的处理单元。在核函数执行期间，将线程块提供给 SM 以供其执行。为支持 GPU 执行尽可能多的并行操作，您通常可以<em>选择线程块数量数倍于指定 GPU 上 SM 数量的网格大小</em>来提升性能。（提高SM的利用率）</p>
<p>此外，SM 会在一个名为<strong>warp</strong>的线程块内创建、管理、调度和执行包含 32 个线程的线程组。值得注意的是，可以<em>分配数量数倍于 32 的线程数量</em>来提升性能。</p>
<h3 id="以编程方式查询GPU设备属性">以编程方式查询GPU设备属性</h3>
<p>由于 GPU 上的 SM 数量会因所用的特定 GPU 而异，因此为支持可移植性，您不得将 SM 数量硬编码到代码库中。相反，应该以编程方式获取此信息。</p>
<p>以下所示为在 CUDA C/C++ 中获取 C 结构的方法，该结构包含当前处于活动状态的 GPU 设备的多个属性，其中包括设备的 SM 数量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> deviceId;</span><br><span class="line"><span class="built_in">cudaGetDevice</span>(&amp;deviceId);                  <span class="comment">// `deviceId`现在指向活动的GPU</span></span><br><span class="line"></span><br><span class="line">cudaDeviceProp props;</span><br><span class="line"><span class="built_in">cudaGetDeviceProperties</span>(&amp;props, deviceId); <span class="comment">// `props` 现在有很多有用的关于主用GPU设备的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查询设备信息">查询设备信息</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> deviceId;</span><br><span class="line">  <span class="built_in">cudaGetDevice</span>(&amp;deviceId);</span><br><span class="line"></span><br><span class="line">  cudaDeviceProp props;</span><br><span class="line">  <span class="built_in">cudaGetDeviceProperties</span>(&amp;props, deviceId);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> computeCapabilityMajor = props.major;</span><br><span class="line">  <span class="type">int</span> computeCapabilityMinor = props.minor;</span><br><span class="line">  <span class="type">int</span> multiProcessorCount = props.multiProcessorCount;</span><br><span class="line">  <span class="type">int</span> warpSize = props.warpSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Device ID: %d\nNumber of SMs: %d\nCompute Capability Major: %d\nCompute Capability Minor: %d\nWarp Size: %d\n&quot;</span>, deviceId, multiProcessorCount, computeCapabilityMajor, computeCapabilityMinor, warpSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果样式下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312292237862.png" alt="image-20231220165103264"></p>
<ul>
<li><strong>Compute Capability Major（计算能力主版本）：</strong> 这是主要版本号，表示GPU架构的主要特性。较新的主要版本通常支持更多的功能和性能提升。例如，Compute Capability Major 7 表示该GPU属于较新的架构。</li>
<li><strong>Compute Capability Minor（计算能力次版本）：</strong> 这是次要版本号，表示GPU架构的次要特性。通常，次要版本的提升表示一些较小的改进或优化。Compute Capability Minor 5 表示该GPU的次要版本。</li>
</ul>
<h3 id="将网格数调整为SM数，进一步优化矢量加法">将网格数调整为SM数，进一步优化矢量加法</h3>
<p>得知设备信息后，对执行配置进行调整，对01-vector-add.cu进一步优化。</p>
<p>线程块调整为80，线程数调成为640，重复多次运行分析，核函数运行时间约在0.12s左右，相比优化前的2.35s，以及上文的优化结果0.145s，有了不小的进步。</p>
<h2 id="获得统一内存的细节">获得统一内存的细节</h2>
<h3 id="统一内存-UM-的迁移">统一内存(UM)的迁移</h3>
<p>分配 UM 时，内存尚未驻留在主机或设备上。主机或设备尝试访问内存时会发生 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Page_fault">页错误</a>，此时主机或设备会批量迁移所需的数据。同理，当 CPU 或加速系统中的任何 GPU 尝试访问尚未驻留在其上的内存时，会发生页错误并触发迁移。</p>
<p>能够执行页错误并按需迁移内存对于在加速应用程序中简化开发流程大有助益。此外，在处理展示稀疏访问模式的数据时（例如，在应用程序实际运行之前无法得知需要处理的数据时），以及在具有多个 GPU 的加速系统中，数据可能由多个 GPU 设备访问时，按需迁移内存将会带来显著优势。</p>
<p>有些情况下（例如，在运行时之前需要得知数据，以及需要大量连续的内存块时），我们还能有效规避页错误和按需数据迁移所产生的开销。</p>
<p>本实验的后续内容将侧重于对按需迁移的理解，以及如何在分析器输出中识别按需迁移。这些知识可让您在享受按需迁移优势的同时，减少其产生的开销。</p>
<h3 id="练习：探索统一内存（UM）的页错误">练习：探索统一内存（UM）的页错误</h3>
<p><code>nsys profile</code> 会提供描述所分析应用程序 UM 行为的输出。在本练习中，您将对一个简单的应用程序做出一些修改，并会在每次更改后利用 <code>nsys profile</code> 的统一内存输出部分，探讨 UM 数据迁移的行为方式。</p>
<p><a target="_blank" rel="noopener" href="http://dli-604a4aa51b37-46802e.aws.labs.courses.nvidia.com/lab/edit/06-unified-memory-page-faults/01-page-faults.cu"><code>01-page-faults.cu</code></a> 包含 <code>hostFunction</code> 和 <code>gpuKernel</code> 函数，我们可以通过这两个函数并使用数字 <code>1</code> 初始化 <code>2&lt;&lt;24</code> 个单元向量的元素。主机函数和 GPU 核函数目前均未使用。</p>
<p>对于以下 4 个问题中的每一问题，请根据您对 UM 行为的理解，首先假设应会发生何种页错误，然后使用代码库中所提供 2 个函数中的其中一个或同时使用这两个函数编辑 <a target="_blank" rel="noopener" href="http://dli-604a4aa51b37-46802e.aws.labs.courses.nvidia.com/lab/edit/06-unified-memory-page-faults/01-page-faults.cu"><code>01-page-faults.cu</code></a>以创建场景，以便您测试假设。</p>
<p>为了检验您的假设，请使用下面的代码执行单元来编译和分析代码。 一定要记录从<code>nsys profile --stats = true</code>输出中获得的假设以及结果。 在<code>nsys profile --stats = true</code>的输出中，您应该查找以下内容：</p>
<ul>
<li>输出中是否有 <em>CUDA内存操作统计信息</em> 部分？</li>
<li>如果是，这是否表示数据从主机到设备（HtoD）或从设备到主机（DtoH）的迁移？</li>
<li>进行迁移时，输出如何说明有多少个“操作”？ 如果看到许多小的内存迁移操作，则表明按需出现页面错误，并且每次在请求的位置出现页面错误时都会发生小内存迁移。</li>
</ul>
<p>以下是供您探索的方案，以及遇到困难时的解决方案：</p>
<ul>
<li>当仅通过CPU访问统一内存时，是否存在内存迁移和/或页面错误的证据？</li>
<li>当仅通过GPU访问统一内存时，是否有证据表明内存迁移和/或页面错误？</li>
<li>当先由CPU然后由GPU访问统一内存时，是否有证据表明存在内存迁移和/或页面错误？</li>
<li>当先由GPU然后由CPU访问统一内存时，是否存在内存迁移和/或页面错误的证据？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312292238197.png" alt="image-20231223181124188"></p>
<p>上图为<code>nsys profile --stats = true</code>输出内容中显示的数据从设备到主机的迁移DtoH，总操作数为768，可以看到有许多小内存的迁移操作，验证了按需出现页面错误，并且每次在请求的位置出现页面错误时都会发生小内存迁移。</p>
<p>当 <code>nsys profile</code> 给出核函数所需的执行时间时，则在此函数执行期间发生的主机到设备页错误和数据迁移都会包含在所显示的执行时间中。故可以通过减少UM页错误和数据迁移的发生缩短核函数运行时间。</p>
<h2 id="异步内存预取">异步内存预取</h2>
<p>在主机到设备和设备到主机的内存传输过程中，我们使用一种技术来减少页错误和按需内存迁移成本，此强大技术称为<strong>异步内存预取</strong>。通过此技术，程序员可以在应用程序代码使用统一内存 (UM) 之前，在后台将其异步迁移至系统中的任何 CPU 或 GPU 设备。此举可以减少页错误和按需数据迁移所带来的成本，并进而提高 GPU 核函数和 CPU 函数的性能。</p>
<p>此外，预取往往会以更大的数据块来迁移数据，因此其迁移次数要低于按需迁移。此技术非常适用于以下情况：在运行时之前已知数据访问需求且数据访问并未采用稀疏模式。</p>
<p>CUDA 可通过 <code>cudaMemPrefetchAsync</code> 函数，轻松将托管内存异步预取到 GPU 设备或 CPU。以下所示为如何使用该函数将数据预取到当前处于活动状态的 GPU 设备，然后再预取到 CPU：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> deviceId;</span><br><span class="line"><span class="built_in">cudaGetDevice</span>(&amp;deviceId);                                  <span class="comment">// The ID of the currently active GPU device.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaMemPrefetchAsync</span>(pointerToSomeUMData, size, deviceId);<span class="comment">// 预取pointerToSomeUMData处size大小的数据至活动的GPU设备</span></span><br><span class="line"><span class="built_in">cudaMemPrefetchAsync</span>(pointerToSomeUMData, size, cudaCpuDeviceId); <span class="comment">// 预取回主机.`cudaCpuDeviceId`是可以直接使用的变量</span></span><br></pre></td></tr></table></figure>
<h3 id="练习：异步内存预取">练习：异步内存预取</h3>
<p>在 01-vector-add.cu应用程序中使用 <code>cudaMemPrefetchAsync</code> 函数开展 实验，以探究其会对页错误和内存迁移产生何种影响。</p>
<p>结果：可以看到内存传输次数减少了，但是每次传输的量增加了，并且内核执行时间大大减少了。</p>
<h1><strong>异步流及 CUDA C/C++ 应用程序的可视化性能分析</strong></h1>
<p>CUDA工具包附带了 <strong>Nsight Systems</strong>，这是一个功能强大的GUI应用程序，可支持CUDA应用程序的开发。 Nsight Systems为被加速的应用程序生成图形化的活动时间表，其中包含有关CUDA API调用、内核执行、内存活动以及<strong>CUDA流</strong>的使用的详细信息。</p>
<h2 id="学习目标-2">学习目标</h2>
<p>在完成本练习后，您将能够：</p>
<ul>
<li>使用<strong>Nsight Systems</strong>直观地描述由GPU加速的CUDA应用程序的时间表。</li>
<li>使用<strong>Nsight Systems</strong>识别和利用CUDA应用程序中的优化机会。</li>
<li>利用CUDA流在被加速的应用程序中并发执行核函数。</li>
<li>（ <strong>可选的进阶内容</strong> ）使用手动的设备内存分配，包括分配固定的内存，以便在并发CUDA流之间异步传输数据。</li>
</ul>
<h2 id="运行Nsight-Systems">运行Nsight Systems</h2>
<p>此处使用的是英伟达配置好的远程桌面，可以直接启动和使用Nsight Systems（但是无比的卡顿），建议在本地配置，进行可视化分析。</p>
<p>主要对前面的各种优化进行可视化分析，故不做记录</p>
<h2 id="并发CUDA流">并发CUDA流</h2>
<p>在 CUDA 编程中，<strong>流</strong>是由按顺序执行的一系列命令构成。在 CUDA 应用程序中，核函数的执行以及一些内存传输均在 CUDA 流中进行。不过直至此时，您仍未直接与 CUDA 流打交道；但实际上您的 CUDA 代码已在名为<em>默认流</em>的流中执行了其核函数。</p>
<p>除默认流以外，CUDA 程序员还可创建并使用非默认 CUDA 流，此举可支持执行多个操作，例如在不同的流中并发执行多个核函数。多流的使用可以为您的加速应用程序带来另外一个层次的并行，并能提供更多应用程序的优化机会。</p>
<p>以下为默认流和非默认流的关系</p>
<ul>
<li>给定流中的所有操作会按序执行。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312291746109.png" alt="image-20231229174627015" style="zoom:50%;" />
<ul>
<li>就不同非默认流中的操作而言，无法保证其会按彼此之间的任何特定顺序执行。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312291747578.png" alt="image-20231229174728331" style="zoom:50%;" />
<ul>
<li>默认流具有阻断能力，即，它会等待其它已在运行的所有流完成当前操作之后才运行，但在其自身运行完毕之前亦会阻碍其它流的运行</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312291748572.png" alt="image-20231229174809215" style="zoom:50%;" />
<h3 id="创建，使用和销毁非默认CUDA流">创建，使用和销毁非默认CUDA流</h3>
<p>以下代码段演示了如何创建，利用和销毁非默认CUDA流。您会注意到，要在非默认CUDA流中启动CUDA核函数，必须将流作为执行配置的第4个可选参数传递给该核函数。到目前为止，您仅利用了执行配置的前两个参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cudaStream_t stream;   <span class="comment">// CUDA流的类型为 `cudaStream_t`</span></span><br><span class="line"><span class="built_in">cudaStreamCreate</span>(&amp;stream); <span class="comment">// 注意，必须将一个指针传递给 `cudaCreateStream`</span></span><br><span class="line"></span><br><span class="line">someKernel&lt;&lt;&lt;number_of_blocks, threads_per_block, <span class="number">0</span>, stream&gt;&gt;&gt;();   <span class="comment">// `stream` 作为第4个EC参数传递</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaStreamDestroy</span>(stream); <span class="comment">// 注意，将值（而不是指针）传递给 `cudaDestroyStream`</span></span><br></pre></td></tr></table></figure>
<p>但值得一提的是，执行配置的第3个可选参数超出了本实验的范围。此参数允许程序员提供<strong>共享内存</strong>中为每个内核启动动态分配的字节数。每个块分配给共享内存的默认字节数为“0”，在本练习的其余部分中，您将传递“ 0”作为该值，以便展示我们感兴趣的第4个参数。</p>
<h3 id="练习-2">练习</h3>
<p>源程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">printNumber</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    printNumber&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以预见核函数的5次启动都在默认流顺次执行，可以用Nsight Systems进行可视化分析。由于核函数的所有 5 次启动均在同一个流中发生，因此看到 5 个核函数顺次执行也就不足为奇。此外，也可以这么说，由于默认流具有阻断作用，所以核函数都会在完成本次启动之后才启动下一次，而事实也是如此。</p>
<p>重构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">printNumber</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    cudaStream_t stream;</span><br><span class="line">    <span class="built_in">cudaStreamCreate</span>(&amp;stream);</span><br><span class="line">    printNumber&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, stream&gt;&gt;&gt;(i);</span><br><span class="line">    <span class="built_in">cudaStreamDestroy</span>(stream);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWith</span><span class="params">(<span class="type">float</span> num, <span class="type">float</span> *a, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; N; i += stride)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i] = num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addVectorsInto</span><span class="params">(<span class="type">float</span> *result, <span class="type">float</span> *a, <span class="type">float</span> *b, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; N; i += stride)</span><br><span class="line">  &#123;</span><br><span class="line">    result[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkElementsAre</span><span class="params">(<span class="type">float</span> target, <span class="type">float</span> *vector, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vector[i] != target)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;FAIL: vector[%d] - %0.0f does not equal %0.0f\n&quot;</span>, i, vector[i], target);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Success! All values calculated correctly.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> deviceId;</span><br><span class="line">  <span class="type">int</span> numberOfSMs;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaGetDevice</span>(&amp;deviceId);</span><br><span class="line">  <span class="built_in">cudaDeviceGetAttribute</span>(&amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">2</span>&lt;&lt;<span class="number">24</span>;</span><br><span class="line">  <span class="type">size_t</span> size = N * <span class="built_in">sizeof</span>(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> *a;</span><br><span class="line">  <span class="type">float</span> *b;</span><br><span class="line">  <span class="type">float</span> *c;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;a, size);</span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;b, size);</span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;c, size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMemPrefetchAsync</span>(a, size, deviceId);</span><br><span class="line">  <span class="built_in">cudaMemPrefetchAsync</span>(b, size, deviceId);</span><br><span class="line">  <span class="built_in">cudaMemPrefetchAsync</span>(c, size, deviceId);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> threadsPerBlock;</span><br><span class="line">  <span class="type">size_t</span> numberOfBlocks;</span><br><span class="line"></span><br><span class="line">  threadsPerBlock = <span class="number">256</span>;</span><br><span class="line">  numberOfBlocks = <span class="number">32</span> * numberOfSMs;</span><br><span class="line"></span><br><span class="line">  cudaError_t addVectorsErr;</span><br><span class="line">  cudaError_t asyncErr;</span><br><span class="line"></span><br><span class="line">  initWith&lt;&lt;&lt;numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(<span class="number">3</span>, a, N);</span><br><span class="line">  initWith&lt;&lt;&lt;numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(<span class="number">4</span>, b, N);</span><br><span class="line">  initWith&lt;&lt;&lt;numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(<span class="number">0</span>, c, N);</span><br><span class="line"></span><br><span class="line">  addVectorsInto&lt;&lt;&lt;numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(c, a, b, N);</span><br><span class="line"></span><br><span class="line">  addVectorsErr = <span class="built_in">cudaGetLastError</span>();</span><br><span class="line">  <span class="keyword">if</span>(addVectorsErr != cudaSuccess) <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(addVectorsErr));</span><br><span class="line"></span><br><span class="line">  asyncErr = <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">  <span class="keyword">if</span>(asyncErr != cudaSuccess) <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(asyncErr));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMemPrefetchAsync</span>(c, size, cudaCpuDeviceId);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">checkElementsAre</span>(<span class="number">7</span>, c, N);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaFree</span>(a);</span><br><span class="line">  <span class="built_in">cudaFree</span>(b);</span><br><span class="line">  <span class="built_in">cudaFree</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWith</span><span class="params">(<span class="type">float</span> num, <span class="type">float</span> *a, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; N; i += stride)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i] = num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addVectorsInto</span><span class="params">(<span class="type">float</span> *result, <span class="type">float</span> *a, <span class="type">float</span> *b, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; N; i += stride)</span><br><span class="line">  &#123;</span><br><span class="line">    result[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkElementsAre</span><span class="params">(<span class="type">float</span> target, <span class="type">float</span> *vector, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vector[i] != target)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;FAIL: vector[%d] - %0.0f does not equal %0.0f\n&quot;</span>, i, vector[i], target);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Success! All values calculated correctly.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> deviceId;</span><br><span class="line">  <span class="type">int</span> numberOfSMs;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaGetDevice</span>(&amp;deviceId);</span><br><span class="line">  <span class="built_in">cudaDeviceGetAttribute</span>(&amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">2</span>&lt;&lt;<span class="number">24</span>;</span><br><span class="line">  <span class="type">size_t</span> size = N * <span class="built_in">sizeof</span>(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> *a;</span><br><span class="line">  <span class="type">float</span> *b;</span><br><span class="line">  <span class="type">float</span> *c;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;a, size);</span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;b, size);</span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;c, size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMemPrefetchAsync</span>(a, size, deviceId);</span><br><span class="line">  <span class="built_in">cudaMemPrefetchAsync</span>(b, size, deviceId);</span><br><span class="line">  <span class="built_in">cudaMemPrefetchAsync</span>(c, size, deviceId);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> threadsPerBlock;</span><br><span class="line">  <span class="type">size_t</span> numberOfBlocks;</span><br><span class="line"></span><br><span class="line">  threadsPerBlock = <span class="number">256</span>;</span><br><span class="line">  numberOfBlocks = <span class="number">32</span> * numberOfSMs;</span><br><span class="line"></span><br><span class="line">  cudaError_t addVectorsErr;</span><br><span class="line">  cudaError_t asyncErr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Create 3 streams to run initialize the 3 data vectors in parallel.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  cudaStream_t stream1, stream2, stream3;</span><br><span class="line">  <span class="built_in">cudaStreamCreate</span>(&amp;stream1);</span><br><span class="line">  <span class="built_in">cudaStreamCreate</span>(&amp;stream2);</span><br><span class="line">  <span class="built_in">cudaStreamCreate</span>(&amp;stream3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Give each `initWith` launch its own non-standard stream.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  initWith&lt;&lt;&lt;numberOfBlocks, threadsPerBlock, <span class="number">0</span>, stream1&gt;&gt;&gt;(<span class="number">3</span>, a, N);</span><br><span class="line">  initWith&lt;&lt;&lt;numberOfBlocks, threadsPerBlock, <span class="number">0</span>, stream2&gt;&gt;&gt;(<span class="number">4</span>, b, N);</span><br><span class="line">  initWith&lt;&lt;&lt;numberOfBlocks, threadsPerBlock, <span class="number">0</span>, stream3&gt;&gt;&gt;(<span class="number">0</span>, c, N);</span><br><span class="line"></span><br><span class="line">  addVectorsInto&lt;&lt;&lt;numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(c, a, b, N);</span><br><span class="line"></span><br><span class="line">  addVectorsErr = <span class="built_in">cudaGetLastError</span>();</span><br><span class="line">  <span class="keyword">if</span>(addVectorsErr != cudaSuccess) <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(addVectorsErr));</span><br><span class="line"></span><br><span class="line">  asyncErr = <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">  <span class="keyword">if</span>(asyncErr != cudaSuccess) <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(asyncErr));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMemPrefetchAsync</span>(c, size, cudaCpuDeviceId);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">checkElementsAre</span>(<span class="number">7</span>, c, N);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Destroy streams when they are no longer needed.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaStreamDestroy</span>(stream1);</span><br><span class="line">  <span class="built_in">cudaStreamDestroy</span>(stream2);</span><br><span class="line">  <span class="built_in">cudaStreamDestroy</span>(stream3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaFree</span>(a);</span><br><span class="line">  <span class="built_in">cudaFree</span>(b);</span><br><span class="line">  <span class="built_in">cudaFree</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最终任务：加速和优化N体模拟器">最终任务：加速和优化N体模拟器</h2>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/N-body_problem">n-body</a> 模拟器可以预测通过引力相互作用的一组物体的个体运动。<a target="_blank" rel="noopener" href="http://dli-604a4aa51b37-c4c714.aws.labs.courses.nvidia.com/lab/edit/09-nbody/01-nbody.cu">01-nbody.cu</a> 包含一个简单而有效的 n-body 模拟器，适合用于在三维空间移动的物体。我们可通过向该应用程序传递一个命令行参数以影响系统中的物体数量。</p>
<p>以目前的仅用CPU的情况下，此应用程序大约需要5秒钟才能运行4096个物体，需要<strong>20分钟</strong>才能运行65536个物体。您的任务是用GPU加速程序，同时保持仿真的正确性。</p>
<p>源程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;files.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTENING 1e-9f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each body contains x, y, and z coordinate positions,</span></span><br><span class="line"><span class="comment"> * as well as velocities in the x, y, and z directions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="type">float</span> x, y, z, vx, vy, vz; &#125; Body;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the gravitational impact of all bodies in the system</span></span><br><span class="line"><span class="comment"> * on all others.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bodyForce</span><span class="params">(Body *p, <span class="type">float</span> dt, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">float</span> Fx = <span class="number">0.0f</span>; <span class="type">float</span> Fy = <span class="number">0.0f</span>; <span class="type">float</span> Fz = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="type">float</span> dx = p[j].x - p[i].x;</span><br><span class="line">      <span class="type">float</span> dy = p[j].y - p[i].y;</span><br><span class="line">      <span class="type">float</span> dz = p[j].z - p[i].z;</span><br><span class="line">      <span class="type">float</span> distSqr = dx*dx + dy*dy + dz*dz + SOFTENING;</span><br><span class="line">      <span class="type">float</span> invDist = <span class="built_in">rsqrtf</span>(distSqr);</span><br><span class="line">      <span class="type">float</span> invDist3 = invDist * invDist * invDist;</span><br><span class="line"></span><br><span class="line">      Fx += dx * invDist3; Fy += dy * invDist3; Fz += dz * invDist3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p[i].vx += dt*Fx; p[i].vy += dt*Fy; p[i].vz += dt*Fz;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">const</span> <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The assessment will test against both 2&lt;11 and 2&lt;15.</span></span><br><span class="line">  <span class="comment">// Feel free to pass the command line argument 15 when you gernate ./nbody report files</span></span><br><span class="line">  <span class="type">int</span> nBodies = <span class="number">2</span>&lt;&lt;<span class="number">11</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) nBodies = <span class="number">2</span>&lt;&lt;<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The assessment will pass hidden initialized values to check for correctness.</span></span><br><span class="line">  <span class="comment">// You should not make changes to these files, or else the assessment will not work.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * initialized_values;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * solution_values;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nBodies == <span class="number">2</span>&lt;&lt;<span class="number">11</span>) &#123;</span><br><span class="line">    initialized_values = <span class="string">&quot;files/initialized_4096&quot;</span>;</span><br><span class="line">    solution_values = <span class="string">&quot;files/solution_4096&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// nBodies == 2&lt;&lt;15</span></span><br><span class="line">    initialized_values = <span class="string">&quot;files/initialized_65536&quot;</span>;</span><br><span class="line">    solution_values = <span class="string">&quot;files/solution_65536&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) initialized_values = argv[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">3</span>) solution_values = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> dt = <span class="number">0.01f</span>; <span class="comment">// Time step</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> nIters = <span class="number">10</span>;  <span class="comment">// Simulation iterations</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bytes = nBodies * <span class="built_in">sizeof</span>(Body);</span><br><span class="line">  <span class="type">float</span> *buf;</span><br><span class="line"></span><br><span class="line">  buf = (<span class="type">float</span> *)<span class="built_in">malloc</span>(bytes);</span><br><span class="line"></span><br><span class="line">  Body *p = (Body*)buf;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read_values_from_file</span>(initialized_values, buf, bytes);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> totalTime = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * This simulation will run for 10 cycles of time, calculating gravitational</span></span><br><span class="line"><span class="comment">   * interaction amongst bodies, and adjusting their positions to reflect.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> iter = <span class="number">0</span>; iter &lt; nIters; iter++) &#123;</span><br><span class="line">    <span class="built_in">StartTimer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * You will likely wish to refactor the work being done in `bodyForce`,</span></span><br><span class="line"><span class="comment">   * and potentially the work to integrate the positions.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bodyForce</span>(p, dt, nBodies); <span class="comment">// compute interbody forces</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * This position integration cannot occur until this round of `bodyForce` has completed.</span></span><br><span class="line"><span class="comment">   * Also, the next round of `bodyForce` cannot begin until the integration is complete.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nBodies; i++) &#123; <span class="comment">// integrate position</span></span><br><span class="line">      p[i].x += p[i].vx*dt;</span><br><span class="line">      p[i].y += p[i].vy*dt;</span><br><span class="line">      p[i].z += p[i].vz*dt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> tElapsed = <span class="built_in">GetTimer</span>() / <span class="number">1000.0</span>;</span><br><span class="line">    totalTime += tElapsed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> avgTime = totalTime / (<span class="type">double</span>)(nIters);</span><br><span class="line">  <span class="type">float</span> billionsOfOpsPerSecond = <span class="number">1e-9</span> * nBodies * nBodies / avgTime;</span><br><span class="line">  <span class="built_in">write_values_to_file</span>(solution_values, buf, bytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You will likely enjoy watching this value grow as you accelerate the application,</span></span><br><span class="line">  <span class="comment">// but beware that a failure to correctly synchronize the device might result in</span></span><br><span class="line">  <span class="comment">// unrealistically high values.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%0.3f Billion Interactions / second&quot;</span>, billionsOfOpsPerSecond);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化热点如下：</p>
<ol>
<li>将bodyforce函数改为核函数，外层循环可以优化，内层循环具有顺序依赖故不做改动</li>
<li>将bodyforce函数执行后的将引力集成到各物体位置的for循环改为核函数。“该集成不仅需在 <code>bodyForce</code> 函数运行后进行，并且需在下一次调用 <code>bodyForce</code> 函数之前完成。”所以，在执行前添加cudaDeviceSynchronize()语句</li>
<li>执行配置根据SMs和wraps数量进行配置（此处线程数越大，核函数运行时间反而变长，取32和64的运行时间相对较优）</li>
</ol>
<p>重构结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;files.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTENING 1e-9f</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="type">float</span> x, y, z, vx, vy, vz; &#125; Body;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">bodyForce</span><span class="params">(Body *p, <span class="type">float</span> dt, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; n; i += stride)&#123;</span><br><span class="line">    <span class="type">float</span> Fx = <span class="number">0.0f</span>; <span class="type">float</span> Fy = <span class="number">0.0f</span>; <span class="type">float</span> Fz = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="type">float</span> dx = p[j].x - p[i].x;</span><br><span class="line">      <span class="type">float</span> dy = p[j].y - p[i].y;</span><br><span class="line">      <span class="type">float</span> dz = p[j].z - p[i].z;</span><br><span class="line">      <span class="type">float</span> distSqr = dx*dx + dy*dy + dz*dz + SOFTENING;</span><br><span class="line">      <span class="type">float</span> invDist = <span class="built_in">rsqrtf</span>(distSqr);</span><br><span class="line">      <span class="type">float</span> invDist3 = invDist * invDist * invDist;</span><br><span class="line"></span><br><span class="line">      Fx += dx * invDist3; Fy += dy * invDist3; Fz += dz * invDist3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p[i].vx += dt*Fx; p[i].vy += dt*Fy; p[i].vz += dt*Fz;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">integrate_position</span><span class="params">(Body *p,<span class="type">float</span> dt,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">       <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; n; i += stride) &#123;</span><br><span class="line">                <span class="comment">// integrate position</span></span><br><span class="line">                p[i].x += p[i].vx*dt;</span><br><span class="line">                p[i].y += p[i].vy*dt;</span><br><span class="line">                p[i].z += p[i].vz*dt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">const</span> <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> deviceId;</span><br><span class="line">  <span class="type">int</span> numberOfSMs;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaGetDevice</span>(&amp;deviceId);</span><br><span class="line">  <span class="built_in">cudaDeviceGetAttribute</span>(&amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> nBodies = <span class="number">2</span>&lt;&lt;<span class="number">11</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) nBodies = <span class="number">2</span>&lt;&lt;<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * initialized_values;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * solution_values;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nBodies == <span class="number">2</span>&lt;&lt;<span class="number">11</span>) &#123;</span><br><span class="line">    initialized_values = <span class="string">&quot;files/initialized_4096&quot;</span>;</span><br><span class="line">    solution_values = <span class="string">&quot;files/solution_4096&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// nBodies == 2&lt;&lt;15</span></span><br><span class="line">    initialized_values = <span class="string">&quot;files/initialized_65536&quot;</span>;</span><br><span class="line">    solution_values = <span class="string">&quot;files/solution_65536&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) initialized_values = argv[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">3</span>) solution_values = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> dt = <span class="number">0.01f</span>; <span class="comment">// Time step</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> nIters = <span class="number">10</span>;  <span class="comment">// Simulation iterations</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bytes = nBodies * <span class="built_in">sizeof</span>(Body);</span><br><span class="line">  <span class="type">float</span> *buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//buf = (float *)malloc(bytes);</span></span><br><span class="line">  <span class="built_in">cudaMallocManaged</span>(&amp;buf, bytes);</span><br><span class="line">  </span><br><span class="line">  Body *p = (Body*)buf;</span><br><span class="line">  <span class="comment">//cudaMemPrefetchAsync(p, bytes, deviceId);</span></span><br><span class="line">  <span class="type">size_t</span> threadsPerBlock = <span class="number">64</span>;</span><br><span class="line">  <span class="type">size_t</span> numberOfBlocks = <span class="number">32</span> * numberOfSMs;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">read_values_from_file</span>(initialized_values, buf, bytes);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> totalTime = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> iter = <span class="number">0</span>; iter &lt; nIters; iter++) &#123;</span><br><span class="line">    <span class="built_in">StartTimer</span>();</span><br><span class="line">    <span class="comment">//cudaStream_t stream;   // CUDA流的类型为 `cudaStream_t`</span></span><br><span class="line">    <span class="comment">//cudaStreamCreate(&amp;stream); </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bodyForce&lt;&lt;&lt; numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(p, dt, nBodies); <span class="comment">// compute interbody forces</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    integrate_position&lt;&lt;&lt; numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(p, dt, nBodies);</span><br><span class="line">    <span class="comment">//cudaDeviceSynchronize();</span></span><br><span class="line">    <span class="comment">//cudaStreamDestroy(stream); </span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> tElapsed = <span class="built_in">GetTimer</span>() / <span class="number">1000.0</span>;</span><br><span class="line">    totalTime += tElapsed;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//cudaDeviceSynchronize();</span></span><br><span class="line">  <span class="type">double</span> avgTime = totalTime / (<span class="type">double</span>)(nIters);</span><br><span class="line">  <span class="type">float</span> billionsOfOpsPerSecond = <span class="number">1e-9</span> * nBodies * nBodies / avgTime;</span><br><span class="line">  <span class="built_in">write_values_to_file</span>(solution_values, buf, bytes);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%0.3f Billion Interactions / second&quot;</span>, billionsOfOpsPerSecond);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaFree</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后优化结果，计算4096个物体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">您的应用程序运行了: 0.1543秒</span><br><span class="line">您的应用程序运行速度是  22.358 Billion Interactions / second</span><br></pre></td></tr></table></figure>
<p>计算65536个物体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">您的应用程序运行了: 0.4912秒</span><br><span class="line">您的应用程序运行速度是  121.163 Billion Interactions / second</span><br></pre></td></tr></table></figure>
<p>建议结合可视化分析，也许可以得到更优的结果。（本人由于懒得部署本地Nsight Systems，且英伟达提供的远程桌面过于卡顿，故没有结合可视化分析。虽然尝试了异步内存预取和使用非默认流，但是效果并不显著，因为没法进行可视化分析，我也不清楚内存转移时间是否缩短和不同非默认流是否并行，所以使用可视化分析，可能可以进行进一步的优化）</p>
<h2 id="小结">小结</h2>
<p>姑且算是接触了cuda c编程的皮毛。缘由是上学期心头一热选的公选课，但由于要跨校区上课，所以也没去过几节课（别问，就是懒）。没退课的原因就是感觉cuda加速在以后可能会发挥作用，而且这是学校帮忙兑换的Nvidia线上自主培训课程，价值89刀，薅羊毛谁不喜欢。</p>
<p>平时没学，为了完成大作业，就在这几周速通了，学习记录在这篇blog。此外由于运行都是在英伟达提供的远程云环境中，少了配置cuda环境的许多麻烦。上周完成大作业的时候，跌跌撞撞地配了快一天的环境😅，如果后面有想法，打算再写篇博客记录下环境配置。</p>
<hr>
<p>——2023年倒数第三天的晚上。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://forrest-wcb.github.io">Forrest</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://forrest-wcb.github.io/2023/12/29/cuda/">https://forrest-wcb.github.io/2023/12/29/cuda/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://forrest-wcb.github.io" target="_blank">Forrest's Blog🍭</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cuda%E5%8A%A0%E9%80%9F%E8%AE%A1%E7%AE%97/">cuda加速计算</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/forrest-wcb/markdown_img@main/img/202312292229107.jpg" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/09/14/poems/" title="拾珠"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">拾珠</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">CUDA C&#x2F;C++编程的学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BAGPU%E7%BC%96%E5%86%99%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">为GPU编写应用程序代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%8A%A0%E9%80%9F%E5%90%8E%E7%9A%84CUDA%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">编译并运行加速后的CUDA代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A1%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">启动并行运行的核函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%9D%97%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.</span> <span class="toc-text">线程和块的索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E9%80%9Ffor%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.</span> <span class="toc-text">加速for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8D%95%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%9D%97%E5%8A%A0%E9%80%9Ffor%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">练习：使用单个线程块加速for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E7%BA%BF%E7%A8%8B%E5%9D%97%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">调整线程块的大小以实现更多的并行化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%B0%86%E8%A6%81%E5%9C%A8GPU%E5%92%8CCPU%E4%B8%8A%E8%AE%BF%E9%97%AE%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">1.6.</span> <span class="toc-text">分配将要在GPU和CPU上访问的内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%87%8F%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-number">1.7.</span> <span class="toc-text">网格大小与工作量不匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E7%BD%91%E6%A0%BC%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.8.</span> <span class="toc-text">跨网格的循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CUDA%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.9.1.</span> <span class="toc-text">CUDA错误处理功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E7%BB%B4%E5%92%8C3%E7%BB%B4%E7%9A%84%E7%BD%91%E6%A0%BC%E5%92%8C%E5%9D%97"><span class="toc-number">1.10.</span> <span class="toc-text">2维和3维的网格和块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">使用 CUDA C&#x2F;C++ 统一内存和 Nsight Systems (nsys) 管理加速应用程序内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8nsys%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E5%B8%AE%E5%8A%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%AD%E4%BB%A3%E5%9C%B0%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">使用nsys性能分析器帮助应用程序迭代地进行优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88Streaming-Multiprocessors%EF%BC%89%E5%8F%8A%E6%9F%A5%E8%AF%A2GPU%E7%9A%84%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">流多处理器（Streaming Multiprocessors）及查询GPU的设备配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CWarps"><span class="toc-number">2.3.1.</span> <span class="toc-text">流多处理器和Warps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E6%9F%A5%E8%AF%A2GPU%E8%AE%BE%E5%A4%87%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.2.</span> <span class="toc-text">以编程方式查询GPU设备属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.3.</span> <span class="toc-text">查询设备信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E7%BD%91%E6%A0%BC%E6%95%B0%E8%B0%83%E6%95%B4%E4%B8%BASM%E6%95%B0%EF%BC%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96%E7%9F%A2%E9%87%8F%E5%8A%A0%E6%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">将网格数调整为SM数，进一步优化矢量加法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E7%BB%9F%E4%B8%80%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">2.4.</span> <span class="toc-text">获得统一内存的细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%86%85%E5%AD%98-UM-%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="toc-number">2.4.1.</span> <span class="toc-text">统一内存(UM)的迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%8E%A2%E7%B4%A2%E7%BB%9F%E4%B8%80%E5%86%85%E5%AD%98%EF%BC%88UM%EF%BC%89%E7%9A%84%E9%A1%B5%E9%94%99%E8%AF%AF"><span class="toc-number">2.4.2.</span> <span class="toc-text">练习：探索统一内存（UM）的页错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%86%85%E5%AD%98%E9%A2%84%E5%8F%96"><span class="toc-number">2.5.</span> <span class="toc-text">异步内存预取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%86%85%E5%AD%98%E9%A2%84%E5%8F%96"><span class="toc-number">2.5.1.</span> <span class="toc-text">练习：异步内存预取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">异步流及 CUDA C&#x2F;C++ 应用程序的可视化性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87-2"><span class="toc-number">3.1.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8CNsight-Systems"><span class="toc-number">3.2.</span> <span class="toc-text">运行Nsight Systems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91CUDA%E6%B5%81"><span class="toc-number">3.3.</span> <span class="toc-text">并发CUDA流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%92%8C%E9%94%80%E6%AF%81%E9%9D%9E%E9%BB%98%E8%AE%A4CUDA%E6%B5%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">创建，使用和销毁非默认CUDA流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%BB%BB%E5%8A%A1%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%92%8C%E4%BC%98%E5%8C%96N%E4%BD%93%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">最终任务：加速和优化N体模拟器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Forrest</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-blog-pink.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, {"pageSize":10,"requiredMeta":["nick","mail"],"locale":{"placeholder":"为了您能得到及时回复，烦请填写昵称和邮箱😉"},"avatar":"mm"}))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div class="aplayer no-destroy" data-id="2640265147" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-theme="#2980b9" data-mutex="true" data-order="random" data-lrctype="0"> </div><canvas id="snow"></canvas><script async src="/js/snow.js"></script><script async src="/js/fps.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="算了,摆了,累了,困了,睡了" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":175,"height":350},"mobile":{"show":false},"log":false});</script></body></html>